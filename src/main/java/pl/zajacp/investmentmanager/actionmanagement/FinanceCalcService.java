package pl.zajacp.investmentmanager.actionmanagement;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import pl.zajacp.investmentmanager.products.Investment;
import pl.zajacp.investmentmanager.products.SavingsAccount;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.Year;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import static java.time.temporal.ChronoUnit.DAYS;

@Service
@Transactional
public class FinanceCalcService {

    private final BigDecimal BELKA_TAX = new BigDecimal(0.81);

    public FinanceCalcService() {
    }

    public BigDecimal getInvestmentValueWithReturn(Investment product) {
        long daysValid = DAYS.between(product.getOpenDate(),
                product.getOpenDate().plusMonths(product.getMonthsValid()));

        return product.getValue().add(product.getValue().multiply(product.getInterest())
                .multiply(new BigDecimal(1.0 * daysValid / Year.of(product.getOpenDate().getYear()).length()))
                .multiply(BELKA_TAX).setScale(2, RoundingMode.HALF_UP));
    }

    public List<LocalDate> getCapitalizationDates(SavingsAccount product) {

        /*
         * Create list of dates consisting of last days of months for a whole year.
         */

        List<LocalDate> capitalizationDates = new ArrayList<LocalDate>();
        LocalDate currentDate = product.getCreated();

        for (int i = 0; i < 12; i++) {
            YearMonth yearMonth = YearMonth.from(currentDate.plusMonths(i));
            capitalizationDates.add(yearMonth.atEndOfMonth());
        }
        return capitalizationDates;
    }

    public BigDecimal getFullCapitalization(BigDecimal value, SavingsAccount product, LocalDate date) {
        return getCapitalizedProfit(value, product, date, true).multiply(BELKA_TAX);
    }

    public BigDecimal getAfterPromotionCapitalization(BigDecimal value, SavingsAccount product, LocalDate date) {
        return getCapitalizedProfit(value, product, date, false).multiply(BELKA_TAX);
    }

    private BigDecimal getCapitalizedProfit(BigDecimal value, SavingsAccount product, LocalDate date, boolean isPromotionActive) {

        BigDecimal currentInterest = isPromotionActive ? product.getInterest() : product.getInterestAboveLimit();

        BigDecimal yearFraction = new BigDecimal
                (1.0 * YearMonth.from(date).lengthOfMonth() / YearMonth.from(date).lengthOfYear());

        //equation: value*(1+(interest*yearFraction))
        BigDecimal valueWithoutLimit = value.multiply(BigDecimal.ONE.add(currentInterest.multiply(yearFraction)));

        /*following calculation is necesarry in case the value exceeded promotional account limit */

        //equation: 1-(withoutLimitValue-valueLimit)/(withoutLimitValue-value)
        BigDecimal fullProfitFraction = BigDecimal.ONE.subtract((valueWithoutLimit.subtract(product.getValueLimit())
                .divide(valueWithoutLimit.subtract(value), BigDecimal.ROUND_HALF_UP)));
        if (fullProfitFraction.compareTo(BigDecimal.ONE) > 0) {
            fullProfitFraction = BigDecimal.ONE;
        } else if (fullProfitFraction.compareTo(BigDecimal.ZERO) < 0) {
            fullProfitFraction = BigDecimal.ZERO;
        }

        //value with profit generated by main intere7st rate
        //equation: value*(1+interest/yearFraction)*fullProfitFraction
        BigDecimal fullProfitValue = value.multiply(BigDecimal.ONE.add(currentInterest.multiply(yearFraction)))
                .multiply(fullProfitFraction);

        //value with profit generated by interest rate above limit
        //equation (1-fullProfitFraction)*value*(1+interestAbove/yearFraction)
        BigDecimal limitedProfitValue = BigDecimal.ONE.subtract(fullProfitFraction)
                .multiply(value).multiply(BigDecimal.ONE.add(product.getInterestAboveLimit()));

        return fullProfitValue.add(limitedProfitValue).subtract(value);
    }


    public BigDecimal getFirstOrLastMonthCapitalization(BigDecimal value, SavingsAccount product,
                                                        LocalDate date, MonthType monthType) {
        /*
         * Date used in first and last have to be open/close date, as days number is used for calculation.
         * All other months in between are using capitalization date.
         */
        int daysInMonth = YearMonth.from(date).lengthOfMonth();

        BigDecimal correctedProfit = null;
        BigDecimal secondMonthPart = new BigDecimal(1.0 - (1.0 * date.getDayOfMonth() / daysInMonth));

        if (monthType==MonthType.CLOSURE) {
            BigDecimal firstMonthPart = new BigDecimal(1.0 * date.getDayOfMonth() / daysInMonth);
            secondMonthPart = new BigDecimal(1.0 - (1.0 * date.getDayOfMonth() / daysInMonth));
            BigDecimal firstMonthPartProfit = getFullCapitalization(value, product, date).multiply(firstMonthPart);
            BigDecimal secondMonthPartProfit = getAfterPromotionCapitalization(value, product, date).multiply(secondMonthPart);
            correctedProfit = firstMonthPartProfit.add(secondMonthPart);
        } else {
            correctedProfit = getFullCapitalization(value, product, date).multiply(secondMonthPart);
        }
        return correctedProfit;
    }

    public List<Action> recalculateCapitalizations(SavingsAccount product, boolean fromTodayCalculation) {
        /*
         * Recalculates all capitalization actions including all withdraws and payments. Recalculates either
         * all actions for given product (with past ones), or all future actions starting from current month.
         * It divides actions into months and changes capitalization values in place, month after month.
         */
        List<Action> actions = product.getActions();

//        List<Action> actions = actionRepository.findChronologicalActive(product);
//        List<Action> actions = product.getActions();

        LocalDate currentDate = fromTodayCalculation ? LocalDate.now() : actions.get(0).getActionDate();
        BigDecimal currentValue = product.getValue();

        int currentYear = currentDate.getYear();
        int currentMonth = currentDate.getMonthValue();

        int monthCapitalizationIndex, firstMonthActionIndex = 0;
        int endDateIndex = getEndDateIndex(actions);

        for (int i = 0; i < actions.size(); i++) {
            int actionYear = actions.get(i).getActionDate().getYear();
            int actionMonth = actions.get(i).getActionDate().getMonthValue();

            //In case of calculation from actual date, here it omits past months
            if (fromTodayCalculation && currentMonth > actionMonth && currentYear >= actionYear) {
                firstMonthActionIndex = i + 1;
                continue;
            }

            if (actions.get(i).getActionType() == ActionType.CAPITALIZATION) {
                MonthType monthType;
                monthCapitalizationIndex = i;
                
                if (firstMonthActionIndex == 0) {
                    monthType = MonthType.OPEN;
                } else if (monthCapitalizationIndex < endDateIndex) {
                    monthType = MonthType.VALID;
                } else if (firstMonthActionIndex < endDateIndex && endDateIndex < monthCapitalizationIndex) {
                    monthType = MonthType.CLOSURE;
                } else {
                    monthType = MonthType.POST_VALID;
                }
                                
                List<Action> currentMonthActions = actions.subList(firstMonthActionIndex, monthCapitalizationIndex+1);

                fixMonthlyCapitalization(currentValue, currentMonthActions, monthType);

                System.out.println(firstMonthActionIndex + " / " + monthCapitalizationIndex);
                currentValue = actions.get(i).getAfterActionValue();
                firstMonthActionIndex = monthCapitalizationIndex+1;
            }
        }
        return actions;
    }

    private void fixMonthlyCapitalization(BigDecimal currentValue, List<Action> currentMonthActions, MonthType monthType) {

        SavingsAccount product = (SavingsAccount) currentMonthActions.get(0).getProduct();
        BigDecimal withdraws = BigDecimal.ZERO;
        BigDecimal totalValueChange = currentValue;
        BigDecimal totalCapitalization = BigDecimal.ZERO;
        Action capitalizationAction = currentMonthActions.stream()
                .filter(a->a.getActionType()==ActionType.CAPITALIZATION)
                .findFirst()
                .orElseThrow(NullPointerException::new);

        for (int i = 0; i < currentMonthActions.size(); i++) {
            BigDecimal currentChange = currentMonthActions.get(i).getBalanceChange();
            if (currentChange == null) {
                continue;
            }

            boolean isPayment = currentChange.compareTo(BigDecimal.ZERO) > 0;

            switch (monthType){
                case OPEN:
                    if(isPayment) {
                        totalCapitalization = totalCapitalization.add(getSinglePaymentCapitalization(
                                currentChange, product, currentMonthActions.get(i).getActionDate()));
                    }else{
                        //TODO firstMonthWidthrawCapitalization
                        withdraws = withdraws.subtract(currentChange);
                    }
                case VALID:
                    if(isPayment){
                        totalCapitalization = totalCapitalization.add(getSinglePaymentCapitalization(
                                currentChange, product, currentMonthActions.get(i).getActionDate()));
                    }else{
                        totalCapitalization = totalCapitalization.subtract(getSingleWidthdrawAbsCapitalization(
                                currentChange, product, currentMonthActions.get(i).getActionDate()));
                        withdraws = withdraws.subtract(currentChange);
                    }
                    break;
                case CLOSURE:
                    if(isPayment) {
                        totalCapitalization = totalCapitalization.add(getSinglePaymentCapitalization(
                                currentChange, product, currentMonthActions.get(i).getActionDate()));
                    }else{
                        //TODO  closureMonthWidthrawCapitalization
                        withdraws = withdraws.subtract(currentChange);
                    }
                    break;
                case POST_VALID:
                    //TODO  postValidCapitalization
                    if(!isPayment){
                        withdraws = withdraws.subtract(currentChange);
                    }
                    break;
            }
            totalValueChange = totalValueChange.add(currentChange);
            currentMonthActions.get(i).setAfterActionValue(totalValueChange);
        }

        //rest of unchanged value capitalization
        totalCapitalization = totalCapitalization
                .add(getFullCapitalization(currentValue.subtract(withdraws), product,capitalizationAction.getActionDate()));

        capitalizationAction.setAfterActionValue(totalValueChange.add(totalCapitalization).setScale(2, RoundingMode.HALF_UP));


    }

    private BigDecimal getSinglePaymentCapitalization(BigDecimal value, SavingsAccount product, LocalDate date){
        return getFirstOrLastMonthCapitalization(value, product, date, MonthType.OPEN);
    }

    private BigDecimal getSingleWidthdrawAbsCapitalization(BigDecimal value, SavingsAccount product, LocalDate date){
        BigDecimal secondHalf = getFirstOrLastMonthCapitalization(value, product, date, MonthType.OPEN);
        BigDecimal wholeMonth = getFullCapitalization(value, product, date);
        return wholeMonth.subtract(secondHalf);
    }

    private int getEndDateIndex(List<Action> actions) {
        int endDateIndex = 0;
        for (int i = 0; i < actions.size(); i++) {
            if (actions.get(i).getActionType().equals(ActionType.PRODUCT_CLOSE)) {
                endDateIndex = i;
                break;
            }
        }
        if (endDateIndex == 0) {
            throw new IllegalArgumentException();
        }
        return endDateIndex;
    }

    public Map<LocalDate, BigDecimal> getGain(List<Action> actions) {
        /*
         * Returns map of dates when capitalization occured with calculated gain from open date.
         * */
        Map<LocalDate, BigDecimal> gain = new LinkedHashMap<>();
        BigDecimal currentVal = actions.get(0).getAfterActionValue();

        for (int i = 1; i < actions.size(); i++) {
            Action currentAction = actions.get(i);
            if (currentAction.getActionType() == ActionType.BALANCE_CHANGE) {
                currentVal = currentVal.add(actions.get(i).getBalanceChange());
            } else if (currentAction.getActionType() == ActionType.CAPITALIZATION || currentAction.getProduct() instanceof Investment) {
                gain.put(currentAction.getActionDate(), currentAction.getAfterActionValue().subtract(currentVal)
                        .setScale(2, RoundingMode.HALF_UP));
            }
        }
        return gain;
    }

//    @Getter
//    @Setter
//    class ActionIndexDTO {
//        int
//    }
}